# Phenomenal DX with React Context and Immer

Effortlessly manage deeply nested state in React with a combination of Context and Immer. It's simple, intuitive, and incredibly powerful.

## Introduction

React's Context API is powerful. Immer makes immutability a breeze. Together? They make state management feel like magic. I'm not saying use this over `react-query`, `zustand`, `jotai` etc but if you're after a type-safe, simple, and intuitive way to manage your state using native React API, this is for you.

Imagine a world where managing and updating deeply nested global state without breaking everything else is as simple as:

```typescript
const { state, setState } = useSiteContext();

const handleUpdate = () => {
  setState({
    name: "Updated name",
    deeply: {
      nested: { thing: { value: "updated value" } },
    },
  });
};

// or
// ...
setState((draft) => {
  eply.nested.key.value = `updated value for ${siteName}`;
  draft.another.value = "another value";
});
```

const { siteName } = draft;

draft.de

## Why is this exciting?

Deeply nested states can be a pain to update. With this setup, you can perform updates on nested state objects with ease, without worrying about mutating the original state or dealing with cumbersome object spreading. It uses Immer to do some magic and wrap a reducer pattern in a simple `setState` function that feels like an upgrade on the native `useState` method.

## How to Use

### Direct Update

Want to directly set a deeply nested value? Easy.

```typescript
setState({ deeply: { nested: { thing: { value: "updated value" } } } });
```

### Functional Update

Or, use a function to dynamically compute the next state, especially useful when the next state depends on the current one:

```typescript
setState((draft) => {
  draft.deeply.nested.key.value = `updated value for ${draft.siteName}`;
});
```

### Using Dispatch

For more complex scenarios or when working with actions, use the `dispatch` function:

```typescript
dispatch({
  type: "SET_SITE_CONTEXT",
  value: { deeply: { nested: { first: 111, second: 222 } } },
});
```

## Live Example

To showcase its ease of use, here's a simple component that displays the current state and provides buttons to manipulate it in various ways:

```tsx
import React from "react";
import { useSiteContext } from "./path-to-your-context-file"; // Make sure to update the import path accordingly.

function ExampleComponent() {
  const { state, setState, dispatch } = useSiteContext();

  const handleDirectSetState = () => {
    setState({
      deeply: {
        nested: { first: 789, second: 101112 },
      },
    });
  };

  const handleFunctionalSetState = () => {
    setState((draft) => {
      draft.deeply.nested.first += 1;
    });
  };

  const handleDispatchNewValue = () => {
    dispatch({
      type: "SET_SITE_CONTEXT",
      value: { deeply: { nested: { first: 111, second: 222 } } },
    });
  };

  const handleFunctionalDispatch = () => {
    dispatch({
      type: "SET_SITE_CONTEXT",
      value: (draft) => {
        draft.deeply.nested.second += 2;
      },
    });
  };

  const handleCombinedSetState = () => {
    setState((draft) => {
      draft.deeply.nested.first += 3;
      draft.deeply.nested.second = 0;
    });
  };

  const handleDeeplyNestedDispatch = () => {
    dispatch({
      type: "SET_SITE_CONTEXT",
      value: { deeply: { nested: { first: state.deeply.nested.first * 2 } } },
    });
  };

  return (
    <div>
      <pre>{JSON.stringify(state, null, 2)}</pre>

      <pre>
        {`
setState({
    deeply: {
        nested: { first: 789, second: 101112 }
    }
});
                `}
      </pre>
      <button onClick={handleDirectSetState}>Direct Set State</button>

      <pre>
        {`
setState(draft => {
    draft.deeply.nested.first += 1;
});
                `}
      </pre>
      <button onClick={handleFunctionalSetState}>Functional Set State</button>

      <pre>
        {`
dispatch({
    type: 'SET_SITE_CONTEXT',
    value: { deeply: { nested: { first: 111, second: 222 } } }
});
                `}
      </pre>
      <button onClick={handleDispatchNewValue}>Dispatch New Value</button>

      <pre>
        {`
dispatch({
    type: 'SET_SITE_CONTEXT',
    value: draft => {
        draft.deeply.nested.second += 2;
    }
});
                `}
      </pre>
      <button onClick={handleFunctionalDispatch}>Functional Dispatch</button>

      <pre>
        {`
setState(draft => {
    draft.deeply.nested.first += 3;
    draft.deeply.nested.second = 0;
});
                `}
      </pre>
      <button onClick={handleCombinedSetState}>Combined Set State</button>

      <pre>
        {`
dispatch({
    type: 'SET_SITE_CONTEXT',
    value: { deeply: { nested: { first: state.deeply.nested.first * 2 } } }
});
                `}
      </pre>
      <button onClick={handleDeeplyNestedDispatch}>
        Deeply Nested Dispatch
      </button>
    </div>
  );
}

export { ExampleComponent };
```

## Wrapping Up

Combine the power of React's Context API with Immer for an amazing developer experience. Simplify your state management, especially for deeply nested states, and spend more time building features rather than wrangling with state updates. Enjoy!
